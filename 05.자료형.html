<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 데이터 타입은 크게 8가지로 나뉨

        // 01. 문자열 (String)
        // 02. 숫자 (Number)햣
        // 03. 불리안 (Boolean) {true, false}
        // 04. 배열 (Array)
        // 05. 객체 (Object)
        // 06. 함수 (Funtion)
        // 08. 널 (Null) -> 변수가 의도적으로 '값이 없음'을 나타내도록 설정한 상태
        // (변수를 일시적으로 비워두고 싶을 때 사용하는 값)\값이 있긴 있는데 비워두고 싶을 때
        // (프로그래머가 변수에 의도적으로 '값이 없음'을 할당 할 때 자주 사용)

        // 미정의(undefined) -> 변수가 선언 되었지만, 아직 값이 할당되지 않은 상태(값이 없는 것과는 다름)
        // (변수 선언 후에 초기화 하지 않으면 기본적으로 undefined 값이 할당됨)
        // 의도적으로 undefined을 할당하는 경우는 거의 없음
        // 느슨한 비교 : == (같다), 엄격한 비교 : === (데이터 타입까지 같다)
        // 느슨한 비교에서는 undefined와 Null이 서로 같다고 평가해버림
        // 엄격한 비교에서는 서로 타입이 다르기 때문에 같이 않다고 평가함
        // 널이랑 언디파인드랑 구분잘하기

        // 원시형
        // 이 여덟까지의 데이터 타입을 두가지의 유형으로 또 나눌 수 있음 1. 원시형 2.참조형 
        // 변경할 수 없는 값, 한 번 생성되면 변경 불가능
        // 새로운 값을 할당하면 기존 값이 아닌 새로운 값이 메모리에 저장됨
        // 변수에 직접 저장됨, 값으로 비교됨, 간단한 값, 숫자, 문자 등...
        

        // 01. 문자형(String)

        //변화될 값인것 같으면 let, 변하지 않을 값인것 같으면 const, let을 남발하면 변수명이 겹쳐서 오류가 날수잇음
        
        const string1 = "world!"; 
        // 기호를 사용하여 데이터를 만들었음.
        const string2 = `hello ${string1}`;
        // 'hello' + string1  -> 문자열로 쓰는 방법
        // es6에서 등장한 방법
        console.log(string2);
        // 백틱 -> 템플릿 리터널
        // 기호를 사용하여 데이터를 만드는 방식을 리터널 방식이라고 함(백틱사용한거?)
        // ${} -> 플레이스 홀더

        //  숫자형(Number)

        const number = -123;
        // 양수 음수를 모두 취급한다.
        const p1 = 3.14;
        // 앞에 숫자가 0 일대는 .14 생략가능 0.14면 0 생략 가능
        console.log(number + 1);
        // 초기값으로 데이터 타입을 판단
        // 변수 (사칙연산+,-,*,/) 숫자 = 가능하다
        console.log(number + undefined);
        // Nan -> not a number
        // 데이터의 타입은 숫자인데 숫자로 표기할 수 없는 값을 뜻함
        // 먼저 나온 데이터의 타입은 숫자로 인식하긴 하는데, 뒤에 미지정수가
        // 나오니까 표기할 수 없음



        // 부동 소수점 오류.
        // 간혹 무한 소수라는 개념이 발생하게 됨
        // 그걸 유한하게 표현하려고 조금 세부적인 값의 초과 또는 손실을 일으킴
        // 결과적으로 덧셈과 같은 소수점 연산은 오류가 발생할 수 있다.
        // 근사치로 표현을 한다. 의도치 않은 연산 오류 발생.

        const a = 0.1;
        // 0.00101010111010
        const b = 0.2;
        // 0.3020200239
        console.log(a + b);
        // 0.3?
        // 흔히 우리가 사용하는 숫자는 10진수임.
        // 근데 컴퓨터에서는 이진법을 사용하기 때문에 우리가 0.2,0.1
        // 을 입력해도 자동으로 이진수로 변환 뒤 계산 -> 다시 십진수로 변환
        // 따라서 이 과정속에 미세한 오류가 발생하기대문에 근사치의 수가 나옴
        // 그래서 숫자 계산을 믿지마라 ->부동소수점 오류



        // (번외) 원하는 소수점까지 잘라내기
        
        console.log((a + b).toFixed(1));
        // 소수점 한자리까지 잘라지는 대신, 문자열이 되어버림
        console.log(Number((a + b).toFixed(1)));
        // 이번 연산 시 숫자로 자료형 변환.
        // 한번 썻다고 다음에도 숫자로 변환되진 않고, 쓰는 당시에만 적용됨
        // 다음 호출 시, 계속 number형이 아님


        // 03. 불린 (Boolean)

        const BoolT = true;
        const BoolF = false;

        if(BoolT){
            // 조건이 부합하면 실행할 실행식
            console.log('hello world!');
        }

        // undefined, null


        //참조형
        //객체, 배열, 함수와 같은 복합적인 데이터 구조를 포함.
        //값을 직접 저장하는 것이 아니라 메모리 상의 '참조'를 통해 데이터를 다룸
        // 원시형은 변수에 실제 데이터를 저장하는 반면,
        //변수에는 실제 데이터가 있는 메모리 주소를 저장함
        // 값을 직접 저장하는 것이 아니라, 메모리 상의 '참조'를 통해 데이터를 다룸
        // 핸드폰에는 많은 공간이 있는데, 그 공간에 들어있는 데이터를 직접 저장하는 것(값이 메모리에 저장, 변수에 직접 저장) -> 원시형
        

        // 자바스크립트는 0번 부터 있음

        // 01.배열 (Array)

        // new 키워드 -> 생성자 함수.
        // 생성자 함수를 통함 array 선언
        // const car = new Array('kia', 'volvo', 'hyundai');

        //리터널 방식, 기호를 사용하여 데이터 생성
        const car = ['kia', 'volvo', 'hyundai'];
        console.log(car);
        // 기아 볼보 현대처럼 배열된게 배열의 아이템, 배열의 요소, array의 엘리먼트라고 불림
        // [] = new array
        // 0 1 2 순으로 들어가 있는 것을 확인할 수 있음
        // length 라는 속성이 있는 것을 볼 수 있음. 배열의 길이임
        // 몇개의 배열 요소가 들어있는지 확인할 수 있음
        console.log(car.lenth);
        console.log(car[2]);
        // car 배열 중에 2번째 아이템를 조회하는 방법
        // 순서로 조회하는 것을 인덱싱이라고 함

        // 몇개가 있는지는 모르겠지만, 맨 마지막 아이템을 조회해야 한다면
        // car라는 함수에서 lenth 3에서 1개를 뺀 게 마지막 아이템?
        // 배열은 123 순이 아니라 012부터 시작하기 때문에 마지막 실제 아이템 개수 3개에서 -1을 해야 실제 자리인 2를 찾을 수 있음
        console.log(car[car.length-1]);


        // 02. 객체 (Object)

        const user1 = {
            name : 'kim',
            age : 40,
            gender : 'man'
        }
        //키(key), 키에 붙은 값을 벨류라고 함, 키와 벨류로 구성
        // 앞에 오는 게 키(프로퍼티), 뒤에 오는 게 벨류(값) 

        console.log(user1);
        // 순서라는 개념 자체가 없음
        // name을 먼저 넣었다고 네임이 먼저 나오지 않음

        console.log(user1.name);
        console.log(user1['age']);
        // .name 이나, ['age'] 나 부르는 방법임

        const user2 = {
            name : 'lee',
            age : 20,
            parent : user1
        }
        // 오브젝트는 중가로

        console.log(user2);


        console.log(user2.parent.name);
        console.log(user2['parent']['name']);
        // 유저2를 사용하여 유저 1의 이름 킴을 불러오는 방법

        const users = [user1, user2];
        
        console.log(users[1].name);
        console.log(users[1]['name']);
        // console.log(users[users.length-1]);
        // 위 배열 유저스를 사용해서 'lee를 나오게 해봐'


        // 03.함수 (Funtion)

        function add(){
            console.log('hello world!');
        }
        // 함수 호출 -> 함수가 실행됨
        add(); //
        console.log(add);

        function getnumber(){
            return 1234; //반환하다. 1234라는 숫자를 뱉어라
        }

        console.log(getnumber()); //리턴해주는 값 1234 나옴, 소가로가 붙은게 함수 도출 형태

        console.log(getnumber);
        console.log(getnumber());

        console.log(typeof getnumber); //타입이 funtion
        console.log(typeof getnumber()); // 타입이 number
        //완전히 다른 값이 출력됨 주의해야함.



        function hello(한수지){ //매개변수(Paramenters)
            console.log(`hello ${한수지}`);
        }

        hello('어선영'); //인자, 아규먼츠(Arguments)
        // 위 세개 칸에 들어있는 어선영이 연결되어 있다는 뜻, 
        // 만약 맨 아래, 아규먼츠에서 어선영이라고 바꾸면 위 함수(매개변수)에서도 함께 바꿔짐


        //(번외) Truthy, Fasley, 참과 거짓

        if(0){
            console.log('참');
        }else{
            console.log('거짓');
        }
           // 0 자체가 거짓, 이프문은 참일 때만 실행됨
        // 널은 값이 없기 때문에 거짓이라 실행되지 않음
        // 거짓 : 0, 빈 문자열 '', Null, false, Undefined, Nan, -0, 0n 

        const firstName = ['kim', 'lee', 'park'];

        if(firstName.length){
            console.log('참이라고 하네요');
        }
        // 펄스트네임 함수에 배열(김, 이, 박)을 비워버리면, 값이 0이기 때문에 거짓이 됨

        // 참 : 거짓 값에 해당하는 데이터를 제외한 모든 것들 
    </script>
</body>
</html>